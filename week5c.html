<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semaine 5C - Builder, Composite, Visitor, Iterator & Strategy</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Style pour le tableau de comparaison */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9em;
            font-family: sans-serif;
            min-width: 400px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
        }
        .comparison-table thead tr {
            background-color: #009879;
            color: #ffffff;
            text-align: left;
        }
        .comparison-table th,
        .comparison-table td {
            padding: 12px 15px;
            border: 1px solid #dddddd;
        }
        .comparison-table tbody tr {
            border-bottom: 1px solid #dddddd;
        }
        .comparison-table tbody tr:nth-of-type(even) {
            background-color: #f3f3f3;
        }
        .comparison-table tbody tr:last-of-type {
            border-bottom: 2px solid #009879;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Semaine 5C</h1>
            <p>Builder + Composite + Visitor + Iterator + Strategy</p>
        </header>

        <nav>
            <a href="index.html">Accueil</a>
            <a href="theory.html">Th√©orie</a>
        </nav>

        <main>

            <h2 id="builder">üèóÔ∏è PATTERN 1 : BUILDER</h2>

            <h3>‚úÖ Comment le reconna√Ætre</h3>
            <div style="background-color: #fafafa; border: 1px solid #ccc; padding: 15px; margin: 20px 0;">
                <p><strong>Trucs et astuces :</strong></p>
                <ul>
                    <li>‚úÖ S√©pare la construction d'un objet complexe de sa repr√©sentation.</li>
                    <li>‚úÖ Une classe <strong>Director</strong> qui orchestre la construction.</li>
                    <li>‚úÖ Une interface/classe abstraite <strong>Builder</strong> avec des m√©thodes de construction.</li>
                    <li>‚úÖ Un <strong>ConcreteBuilder</strong> qui impl√©mente les √©tapes de construction.</li>
                    <li>‚úÖ Le produit final est obtenu via <code>getResult()</code>.</li>
                </ul>
                <p><strong>Phrase cl√© :</strong> "Je reconnais Builder car <code>Lecteur</code> (Director) utilise <code>Fabriquant</code> (ConcreteBuilder) pour construire progressivement un objet <code>Partie</code> (Product)."</p>
            </div>

            <h3>üìä Sch√©ma th√©orique</h3>
            <img src="assets/th/Builder.png" alt="Diagramme Builder Th√©orique" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">

            <h3>üñºÔ∏è Sch√©ma de l'exercice</h3>
            <figure style="text-align:center;">
                <img src="assets/exos/BuilderEXO5.png" alt="Diagramme UML du pattern Builder (Exercice 5C)" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">
                <figcaption>Figure : Diagramme UML du pattern Builder (Exercice 5C)</figcaption>
            </figure>

            <h3>üîç Correspondance Th√©orie / Exercice</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Participants th√©oriques</th>
                        <th>Noms utilis√©s dans le code</th>
                        <th>Explication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Director</strong><br>(Directeur)</td>
                        <td><code>Lecteur</code></td>
                        <td>Dirige le processus de construction en appelant les m√©thodes du Builder dans le bon ordre (lecture du fichier caract√®re par caract√®re).</td>
                    </tr>
                    <tr>
                        <td><strong>Builder</strong><br>(Interface de construction)</td>
                        <td><em>Interface implicite</em></td>
                        <td>D√©finit les m√©thodes de construction (ici impl√©ment√©es directement dans Fabriquant).</td>
                    </tr>
                    <tr>
                        <td><strong>ConcreteBuilder</strong><br>(Constructeur concret)</td>
                        <td><code>Fabriquant</code></td>
                        <td>Impl√©mente la logique de construction : cr√©e les Groupes et Valeurs, g√®re la hi√©rarchie avec une Pile.</td>
                    </tr>
                    <tr>
                        <td><strong>Product</strong><br>(Produit)</td>
                        <td><code>Partie</code><br>(Groupe/Valeur)</td>
                        <td>L'objet complexe r√©sultant de la construction (structure composite hi√©rarchique).</td>
                    </tr>
                    <tr>
                        <td><strong>getResult()</strong></td>
                        <td><code>getResultat()</code></td>
                        <td>M√©thode pour r√©cup√©rer le produit final apr√®s la construction.</td>
                    </tr>
                </tbody>
            </table>

            <h3>üíª Code principal (structure expliqu√©e)</h3>

            <h4>1. Le Director (Lecteur)</h4>
            <p>C'est lui qui orchestre la construction. Il lit le fichier et appelle les bonnes m√©thodes du Builder.</p>
            <pre><code>public class Lecteur {
    private PushbackReader buffer;
    private Fabriquant fabriquant = new Fabriquant();

    public Partie construire() throws IOException {
        int car;
        while ((car = buffer.read()) != -1) {
            if (car == '(') {
                // Construction d'un groupe
                fabriquant.construireGroupe();
            } else if (car == ')') {
                // Fermeture d'un groupe
                fabriquant.fermerGroupe();
            } else if (Character.isDigit((char) car)) {
                // Construction d'une valeur
                int nombre = // ... parsing du nombre
                fabriquant.construireValeur(nombre);
            }
        }
        return fabriquant.getResultat();
    }
}</code></pre>

            <h4>2. Le ConcreteBuilder (Fabriquant)</h4>
            <p>Il construit progressivement la structure composite en utilisant une Pile pour g√©rer la hi√©rarchie.</p>
            <pre><code>public class Fabriquant {
    private Pile pile = new PileImpl();
    private Partie resultat;
    private int niveau = 0;

    // M√©thode de construction : cr√©e un nouveau groupe
    public void construireGroupe() {
        if (!pile.estVide()) {
            Groupe sommet = (Groupe) pile.pop();
            Groupe nouveau = new Groupe(..., ++niveau);
            sommet.add(nouveau);
            pile.push(sommet);
            pile.push(nouveau);
        } else {
            Groupe nouveau = new Groupe(..., 0);
            pile.push(nouveau);
            resultat = nouveau;
        }
    }

    // M√©thode de construction : ferme le groupe courant
    public void fermerGroupe() {
        pile.pop();
        niveau--;
    }

    // M√©thode de construction : ajoute une valeur
    public void construireValeur(int nombre) {
        Valeur number = new Valeur(nombre, niveau + 1);
        if (!pile.estVide()) {
            Groupe sommet = (Groupe) pile.pop();
            sommet.add(number);
            pile.push(sommet);
        } else {
            resultat = number;
        }
    }

    // R√©cup√©ration du produit final
    public Partie getResultat() {
        return resultat;
    }
}</code></pre>

            <h4>3. Le Product (Partie)</h4>
            <p>Le produit complexe r√©sultant : une structure composite hi√©rarchique.</p>
            <pre><code>public interface Partie {
    void demande(Traitement traitement);
    int getNiveau();
}

// Peut √™tre un Groupe (composite) ou une Valeur (leaf)</code></pre>

            <h4>4. Structure auxiliaire : La Pile</h4>
            <p>Le Builder utilise une <code>Pile</code> pour g√©rer les groupes imbriqu√©s pendant la construction.</p>
            <pre><code>public interface Pile {
    boolean estVide();
    void push(Object n);
    Object pop();
    Object sommet();
}</code></pre>

            <hr>

            <h2 id="composite">üå≥ PATTERN 2 : COMPOSITE</h2>

            <h3>‚úÖ Comment le reconna√Ætre</h3>
            <div style="background-color: #fafafa; border: 1px solid #ccc; padding: 15px; margin: 20px 0;">
                <p><strong>Trucs et astuces :</strong></p>
                <ul>
                    <li>‚úÖ Une interface commune pour les feuilles (objets simples) et les conteneurs (groupes).</li>
                    <li>‚úÖ La classe conteneur (Composite) contient une liste de l'interface commune.</li>
                    <li>‚úÖ On peut traiter un groupe comme un objet unique (Uniformit√©).</li>
                    <li>‚úÖ Structure en <strong>arbre</strong>.</li>
                </ul>
                <p><strong>Phrase cl√© :</strong> "Je reconnais Composite car <code>Groupe</code> impl√©mente <code>Partie</code> et contient une liste de <code>Partie</code>. Il traite les groupes et les valeurs de la m√™me fa√ßon."</p>
            </div>

            <h3>üìä Sch√©ma th√©orique</h3>
            <img src="assets/th/Composite.png" alt="Diagramme Composite Th√©orique" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">

            <h3>üñºÔ∏è Sch√©ma de l'exercice</h3>
            <figure style="text-align:center;">
                <img src="assets/exos/Composite.png" alt="Diagramme UML du pattern Composite (Exercice 5C)" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">
                <figcaption>Figure : Diagramme UML du pattern Composite (Exercice 5C)</figcaption>
            </figure>

            <h3>üîç Correspondance Th√©orie / Exercice</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Participants th√©oriques</th>
                        <th>Noms utilis√©s dans le code</th>
                        <th>Explication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Component</strong><br>(Interface Commune)</td>
                        <td><code>Partie</code></td>
                        <td>D√©finit les op√©rations communes (<code>demande</code>, <code>getNiveau</code>) pour les feuilles et les composites.</td>
                    </tr>
                    <tr>
                        <td><strong>Leaf</strong><br>(Feuille)</td>
                        <td><code>Valeur</code></td>
                        <td>Repr√©sente les objets de base qui n'ont pas d'enfants.</td>
                    </tr>
                    <tr>
                        <td><strong>Composite</strong><br>(Conteneur)</td>
                        <td><code>Groupe</code></td>
                        <td>Stocke les enfants (<code>Vector parties</code>) et impl√©mente les op√©rations en les d√©l√©guant souvent aux enfants.</td>
                    </tr>
                    <tr>
                        <td><strong>Operation()</strong><br>(M√©thode m√©tier)</td>
                        <td><code>demande(Traitement t)</code></td>
                        <td>La m√©thode commune appel√©e uniform√©ment sur l'arbre.</td>
                    </tr>
                </tbody>
            </table>

            <h3>üíª Code principal (structure expliqu√©e)</h3>

            <h4>1. L'Interface Component (Partie)</h4>
            <p>C'est le contrat que tout le monde doit respecter. Elle permet de traiter les feuilles et les groupes de la m√™me mani√®re.</p>
            <pre><code>public interface Partie {
    // Op√©ration m√©tier commune
    void demande(Traitement traitement);
    int getNiveau();
}</code></pre>

            <h4>2. Le Composite (Groupe)</h4>
            <p>C'est l'√©l√©ment complexe. Il <strong>contient</strong> d'autres composants (sa liste d'enfants).</p>
            <pre><code>public class Groupe implements Partie {
    // 1. La collection d'enfants (COMPOSITION)
    // Elle est du type de l'interface 'Partie', donc elle peut contenir
    // des Valeurs OU d'autres Groupes (r√©cursivit√©).
    private Vector parties = new Vector();
    
    // 2. M√©thode de gestion des enfants (sp√©cifique au Composite)
    public void add(Partie nouveau) {
        parties.add(nouveau);
    }

    // 3. Impl√©mentation de l'op√©ration commune
    // Ici, le Groupe se passe lui-m√™me au traitement (voir Visitor)
    public void demande(Traitement traitement) {
        traitement.traiteGroupe(this);
    }
}</code></pre>

            <h4>3. La Leaf (Valeur)</h4>
            <p>C'est l'√©l√©ment simple. Il n'a pas de sous-√©l√©ments.</p>
            <pre><code>public class Valeur implements Partie {
    private int nombre;

    public Valeur(int nombre, int niveau) {
        this.nombre = nombre;
    }

    // Pas de liste d'enfants, pas de m√©thode add() !
    
    public void demande(Traitement traitement) {
        traitement.traiteValeur(this);
    }
}</code></pre>


            <hr>

            <h2 id="visitor">üïµÔ∏è PATTERN 3 : VISITOR</h2>

            <h3>‚úÖ Comment le reconna√Ætre</h3>
            <div style="background-color: #fafafa; border: 1px solid #ccc; padding: 15px; margin: 20px 0;">
                <p><strong>Trucs et astuces :</strong></p>
                <ul>
                    <li>‚úÖ On veut ajouter des op√©rations (calculer total, afficher) sans modifier les classes de la structure.</li>
                    <li>‚úÖ Une interface <code>Visitor</code> avec des m√©thodes <code>visitConcretA()</code>, <code>visitConcretB()</code>.</li>
                    <li>‚úÖ Une m√©thode <code>accept(Visitor)</code> dans les √©l√©ments de la structure.</li>
                    <li>‚úÖ M√©canisme de <strong>Double Dispatch</strong> (l'objet rappelle le visiteur en lui donnant son type r√©el).</li>
                </ul>
                <p><strong>Phrase cl√© :</strong> "Je reconnais Visitor gr√¢ce √† l'interface <code>Traitement</code> et la m√©thode <code>demande(Traitement)</code> qui effectue le double dispatch."</p>
            </div>

            <h3>üìä Sch√©ma th√©orique</h3>
            <img src="assets/th/Visitor.png" alt="Diagramme Visitor Th√©orique" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">

            <h3>üñºÔ∏è Sch√©ma de l'exercice</h3>
            <figure style="text-align:center;">
                <img src="assets/exos/Visitor.png" alt="Diagramme UML du pattern Visitor (Exercice 5C)" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">
                
                <figcaption>Figure : Diagramme UML du pattern Visitor (Exercice 5C)</figcaption>
            </figure>

            <h3>üîç Correspondance Th√©orie / Exercice</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Participants th√©oriques</th>
                        <th>Noms utilis√©s dans le code</th>
                        <th>Explication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Visitor</strong><br>(Interface Visiteur)</td>
                        <td><code>Traitement</code></td>
                        <td>D√©finit les signatures de visite pour chaque type concret d'√©l√©ment (<code>traiteValeur</code>, <code>traiteGroupe</code>).</td>
                    </tr>
                    <tr>
                        <td><strong>ConcreteVisitor</strong><br>(Visiteur Concret)</td>
                        <td><code>Totaliseur</code><br><code>Listeur</code></td>
                        <td>Impl√©mente l'algorithme sp√©cifique (ex: sommer les valeurs, afficher le texte).</td>
                    </tr>
                    <tr>
                        <td><strong>Element</strong><br>(Interface visitable)</td>
                        <td><code>Partie</code></td>
                        <td>D√©finit la m√©thode <code>accept</code> (ici <code>demande</code>).</td>
                    </tr>
                    <tr>
                        <td><strong>accept()</strong></td>
                        <td><code>demande(Traitement)</code></td>
                        <td>La porte d'entr√©e pour le visiteur.</td>
                    </tr>
                </tbody>
            </table>

            <h3>üíª Code principal (structure expliqu√©e)</h3>

            <h4>1. L'interface Visitor (Traitement)</h4>
            <pre><code>public interface Traitement {
    // Une m√©thode par type concret √† visiter
    // C'est ici qu'on g√®re le "Double Dispatch"
    void traiteValeur(Valeur unique);
    void traiteGroupe(Groupe plusieurs);
}</code></pre>

            <h4>2. Le Concrete Visitor (Totaliseur)</h4>
            <p>Contient la logique m√©tier (calculer la somme) s√©par√©e de la structure de donn√©es.</p>
            <pre><code>public class Totaliseur implements Traitement {
    private int sommeDesValeurs = 0;

    // Logique pour une Valeur
    public void traiteValeur(Valeur valeur) {
        sommeDesValeurs += valeur.getValeur();
    }

    // Logique pour un Groupe
    public void traiteGroupe(Groupe groupe) {
        // Le visiteur est responsable de parcourir les enfants si n√©cessaire
        Iterator it = groupe.getParties();
        while (it.hasNext()) {
            Partie p = (Partie) it.next();
            // On repasse le visiteur (this) aux enfants
            p.demande(this); 
        }
    }
}</code></pre>

            <hr>

            <h2 id="iterator">üîÑ PATTERN 4 : ITERATOR</h2>

            <h3>‚úÖ Comment le reconna√Ætre</h3>
            <div style="background-color: #fafafa; border: 1px solid #ccc; padding: 15px; margin: 20px 0;">
                <p><strong>Trucs et astuces :</strong></p>
                <ul>
                    <li>‚úÖ Une m√©thode qui retourne un objet <code>Iterator</code> (ou similaire).</li>
                    <li>‚úÖ Permet de parcourir les √©l√©ments d'une collection sans exposer la structure interne.</li>
                    <li>‚úÖ L'it√©rateur fournit les m√©thodes <code>hasNext()</code> et <code>next()</code>.</li>
                    <li>‚úÖ S√©pare la logique de parcours de la structure de donn√©es.</li>
                </ul>
                <p><strong>Phrase cl√© :</strong> "Je reconnais Iterator gr√¢ce √† la m√©thode <code>getParties()</code> qui retourne un <code>Iterator</code> pour parcourir les √©l√©ments sans exposer le <code>Vector</code> interne."</p>
            </div>

            <h3>üìä Sch√©ma th√©orique</h3>
            <img src="assets/th/Iterator.png" alt="Diagramme Iterator Th√©orique" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">

            <h3>üñºÔ∏è Sch√©ma de l'exercice</h3>
            <figure style="text-align:center;">
                <img src="assets/exos/Iterator.png" alt="Diagramme UML du pattern Iterator (Exercice 5C)" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">
                <figcaption>Figure : Diagramme UML du pattern Iterator (Exercice 5C)</figcaption>
            </figure>

            <h3>üîç Correspondance Th√©orie / Exercice</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Participants th√©oriques</th>
                        <th>Noms utilis√©s dans le code</th>
                        <th>Explication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Aggregate</strong><br>(Interface de collection)</td>
                        <td><em>Interface implicite</em></td>
                        <td>D√©finit la m√©thode pour cr√©er un it√©rateur (ici impl√©ment√©e directement dans Groupe).</td>
                    </tr>
                    <tr>
                        <td><strong>ConcreteAggregate</strong><br>(Collection concr√®te)</td>
                        <td><code>Groupe</code></td>
                        <td>Contient la collection r√©elle (<code>Vector parties</code>) et fournit un it√©rateur via <code>getParties()</code>.</td>
                    </tr>
                    <tr>
                        <td><strong>Iterator</strong><br>(Interface d'it√©ration)</td>
                        <td><code>Iterator</code> (Java)</td>
                        <td>Interface standard Java avec <code>hasNext()</code> et <code>next()</code>.</td>
                    </tr>
                    <tr>
                        <td><strong>ConcreteIterator</strong><br>(It√©rateur concret)</td>
                        <td><code>Collections.unmodifiableList().iterator()</code></td>
                        <td>It√©rateur cr√©√© automatiquement par Java, emp√™che les modifications pendant le parcours.</td>
                    </tr>
                </tbody>
            </table>

            <h3>üíª Code principal (structure expliqu√©e)</h3>

            <h4>1. Le ConcreteAggregate (Groupe)</h4>
            <p>La classe qui contient la collection et fournit l'it√©rateur.</p>
            <pre><code>public class Groupe implements Partie {
    // La collection interne (cach√©e de l'ext√©rieur)
    private Vector parties = new Vector();

    // M√©thode qui retourne un it√©rateur
    public Iterator getParties() {
        // Cr√©e un it√©rateur en lecture seule
        return Collections.unmodifiableList(parties).iterator();
    }

    // M√©thode pour ajouter des √©l√©ments
    public void add(Partie nouveau) {
        parties.add(nouveau);
    }
}</code></pre>

            <h4>2. Utilisation de l'Iterator</h4>
            <p>Exemple d'utilisation dans les visiteurs (Totaliseur, Listeur) :</p>
            <pre><code>public void traiteGroupe(Groupe groupe) {
    // R√©cup√®re l'it√©rateur
    Iterator it = groupe.getParties();
    
    // Parcourt les √©l√©ments
    while (it.hasNext()) {
        Partie p = (Partie) it.next();
        p.demande(this);
    }
}</code></pre>

            <h4>3. Avantages</h4>
            <ul>
                <li>üîí <strong>Encapsulation</strong> : Le <code>Vector</code> interne reste priv√©</li>
                <li>üõ°Ô∏è <strong>Protection</strong> : <code>unmodifiableList()</code> emp√™che les modifications</li>
                <li>üîÑ <strong>Standardisation</strong> : Utilise l'interface <code>Iterator</code> standard de Java</li>
                <li>üéØ <strong>Simplicit√©</strong> : Interface uniforme pour parcourir n'importe quelle collection</li>
            </ul>

            <hr>

            <h2 id="strategy">üéØ PATTERN 5 : STRATEGY</h2>

            <h3>‚úÖ Comment le reconna√Ætre</h3>
            <div style="background-color: #fafafa; border: 1px solid #ccc; padding: 15px; margin: 20px 0;">
                <p><strong>Trucs et astuces :</strong></p>
                <ul>
                    <li>‚úÖ Une interface qui d√©finit une famille d'algorithmes interchangeables.</li>
                    <li>‚úÖ Le contexte d√©l√®gue l'ex√©cution √† une strat√©gie pass√©e en param√®tre.</li>
                    <li>‚úÖ Permet de changer l'algorithme dynamiquement sans modifier le contexte.</li>
                    <li>‚úÖ √âvite les multiples <code>if/else</code> ou <code>switch</code> pour choisir un comportement.</li>
                </ul>
                <p><strong>Phrase cl√© :</strong> "Je reconnais Strategy car <code>Partie</code> (Context) d√©l√®gue le traitement √† <code>Traitement</code> (Strategy) pass√© en param√®tre dans <code>demande()</code>."</p>
            </div>

            <h3>üìä Sch√©ma th√©orique</h3>
            <img src="assets/th/strategy.png" alt="Diagramme Strategy Th√©orique" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">

            <h3>üñºÔ∏è Sch√©ma de l'exercice</h3>
            <figure style="text-align:center;">
                <img src="assets/exos/Strategie.png" alt="Diagramme UML du pattern Strategy (Exercice 5C)" style="max-width: 100%; border: 1px solid #ccc; padding: 10px; background: white;">
                <figcaption>Figure : Diagramme UML du pattern Strategy (Exercice 5C)</figcaption>
            </figure>

            <h3>üîç Correspondance Th√©orie / Exercice</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Participants th√©oriques</th>
                        <th>Noms utilis√©s dans le code</th>
                        <th>Explication</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Context</strong><br>(Contexte)</td>
                        <td><code>Partie</code><br>(Valeur, Groupe)</td>
                        <td>D√©l√®gue l'ex√©cution √† la strat√©gie re√ßue via <code>demande(Traitement)</code>.</td>
                    </tr>
                    <tr>
                        <td><strong>Strategy</strong><br>(Interface de strat√©gie)</td>
                        <td><code>Traitement</code></td>
                        <td>D√©finit l'interface commune pour tous les algorithmes de traitement.</td>
                    </tr>
                    <tr>
                        <td><strong>ConcreteStrategyA</strong></td>
                        <td><code>Totaliseur</code></td>
                        <td>Impl√©mente l'algorithme de calcul (somme, moyenne, comptage).</td>
                    </tr>
                    <tr>
                        <td><strong>ConcreteStrategyB</strong></td>
                        <td><code>Listeur</code></td>
                        <td>Impl√©mente l'algorithme d'affichage simple.</td>
                    </tr>
                    <tr>
                        <td><strong>ConcreteStrategyC</strong></td>
                        <td><code>ListeurNom</code></td>
                        <td>Impl√©mente l'algorithme d'affichage avec noms de groupes.</td>
                    </tr>
                </tbody>
            </table>

            <h3>üíª Code principal (structure expliqu√©e)</h3>

            <h4>1. Le Context (Partie)</h4>
            <p>L'interface qui accepte diff√©rentes strat√©gies de traitement.</p>
            <pre><code>public interface Partie {
    // M√©thode qui accepte une strat√©gie
    void demande(Traitement traitement);
    int getNiveau();
}</code></pre>

            <h4>2. Impl√©mentations concr√®tes du Context</h4>
            <p><strong>Valeur</strong> (ConcreteContext) :</p>
            <pre><code>public class Valeur implements Partie {
    private int nombre;

    public void demande(Traitement traitement) {
        // D√©l√®gue √† la strat√©gie
        traitement.traiteValeur(this);
    }
}</code></pre>

            <p><strong>Groupe</strong> (ConcreteContext) :</p>
            <pre><code>public class Groupe implements Partie {
    private Vector parties = new Vector();

    public void demande(Traitement traitement) {
        // D√©l√®gue √† la strat√©gie
        traitement.traiteGroupe(this);
    }
}</code></pre>

            <h4>3. L'interface Strategy (Traitement)</h4>
            <p>D√©finit les m√©thodes que toutes les strat√©gies doivent impl√©menter.</p>
            <pre><code>public interface Traitement {
    void traiteValeur(Valeur unique);
    void traiteGroupe(Groupe plusieurs);
}</code></pre>

            <h4>4. Les ConcreteStrategy</h4>
            
            <p><strong>Totaliseur</strong> - Strat√©gie de calcul :</p>
            <pre><code>public class Totaliseur implements Traitement {
    private int sommeDesValeurs = 0;
    private int nombreDeValeurs = 0;

    public void traiteValeur(Valeur valeur) {
        nombreDeValeurs++;
        sommeDesValeurs += valeur.getValeur();
    }

    public void traiteGroupe(Groupe groupe) {
        Iterator it = groupe.getParties();
        while (it.hasNext()) {
            Partie p = (Partie) it.next();
            p.demande(this); // Propagation r√©cursive
        }
    }
}</code></pre>

            <p><strong>Listeur</strong> - Strat√©gie d'affichage simple :</p>
            <pre><code>public class Listeur implements Traitement {
    public void traiteValeur(Valeur valeur) {
        System.out.print(valeur.getValeur() + " ");
    }

    public void traiteGroupe(Groupe groupe) {
        System.out.print("( ");
        Iterator it = groupe.getParties();
        while (it.hasNext()) {
            Partie p = (Partie) it.next();
            p.demande(this);
        }
        System.out.print(") ");
    }
}</code></pre>

            <h4>5. Utilisation dynamique des strat√©gies</h4>
            <pre><code>// Dans Main.java
Partie partie = lecteur.construire();

// On change de strat√©gie dynamiquement
partie.demande(new Listeur());      // Affichage simple
partie.demande(new Totaliseur());   // Calculs
partie.demande(new ListeurNom());   // Affichage avec noms</code></pre>

            <h3>üîÑ Strategy vs Visitor</h3>
            <div style="background-color: #e7f3ff; border: 1px solid #0066cc; padding: 15px; margin: 20px 0;">
                <p><strong>Dans cet exercice, Strategy et Visitor sont combin√©s !</strong></p>
                <ul>
                    <li><strong>Aspect Strategy :</strong> La m√©thode <code>demande()</code> accepte diff√©rentes strat√©gies de traitement interchangeables.</li>
                    <li><strong>Aspect Visitor :</strong> Le double dispatch permet d'ex√©cuter la bonne m√©thode selon le type r√©el (Valeur ou Groupe).</li>
                </ul>
                <p>üí° <strong>En r√©sum√© :</strong> <code>demande(Traitement)</code> est √† la fois <code>accept(Visitor)</code> et <code>executeStrategy(Strategy)</code> !</p>
            </div>

            <hr>

            <h2>üí° Conseils Suppl√©mentaires</h2>

            <h3>‚ö†Ô∏è Pi√®ges √† √©viter</h3>

            <div style="background-color: #fff3cd; border: 1px solid #856404; padding: 15px; margin: 20px 0;">
                <h4>Composite vs Decorator</h4>
                <ul>
                    <li><strong>Composite :</strong> Relation 1-N (Arbre). Le conteneur a une liste d'enfants. Uniformit√©.</li>
                    <li><strong>Decorator :</strong> Relation 1-1 (Enveloppe). Ajoute du comportement dynamiquement.</li>
                </ul>

                <h4>Visitor vs Strategy</h4>
                <ul>
                    <li><strong>Visitor :</strong> Focus sur le <strong>double dispatch</strong> pour ex√©cuter la bonne op√©ration selon le type r√©el.</li>
                    <li><strong>Strategy :</strong> Focus sur le <strong>changement d'algorithme</strong> de mani√®re interchangeable.</li>
                    <li><strong>Dans cet exercice :</strong> Les deux patterns sont combin√©s dans <code>demande(Traitement)</code> !</li>
                </ul>

                <h4>Visitor vs Iterator</h4>
                <ul>
                    <li><strong>Iterator :</strong> Sert juste √† <strong>parcourir</strong> la structure s√©quentiellement.</li>
                    <li><strong>Visitor :</strong> Sert √† <strong>ex√©cuter une op√©ration</strong> diff√©rente selon le type r√©el de l'objet.</li>
                </ul>
            </div>
            
            <h3>üí° R√©capitulatif</h3>
            <p>Dans cet exercice, <strong>cinq patterns</strong> travaillent ensemble :</p>
            <ul>
                <li><strong>Builder</strong> : Construit progressivement la structure lors de la lecture du fichier</li>
                <li><strong>Composite</strong> : Organise la structure en arbre (Groupe et Valeur)</li>
                <li><strong>Visitor</strong> : Permet d'ajouter des op√©rations sans modifier la structure (double dispatch)</li>
                <li><strong>Iterator</strong> : Permet de parcourir les √©l√©ments sans exposer leur impl√©mentation interne</li>
                <li><strong>Strategy</strong> : Permet de changer dynamiquement l'algorithme de traitement (Totaliseur, Listeur, ListeurNom)</li>
            </ul>
            <p><em>Note : Strategy et Visitor se combinent dans la m√©thode <code>demande(Traitement)</code> !</em></p>

        </main>

        <footer>
            <p>¬© 2024 Design Patterns Course</p>
        </footer>
    </div>
</body>
</html>