<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Th√©orie - Design Patterns</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Design Patterns - Th√©orie</h1>
        </header>

        <nav>
            <a href="index.html">Accueil</a>
            <a href="theory.html">Th√©orie</a>
        </nav>

        <main>
            <h2>ü§î Les 3 Questions Fondamentales</h2>
            
            <div style="background-color: #fafafa; border: 2px solid #333; padding: 20px; margin: 20px 0;">
                <h3>Pose-toi la question : Quel est le probl√®me fondamental ?</h3>
                
                <p><strong>1. Est-ce que c'est difficile de CR√âER l'objet ?</strong></p>
                <p>‚Üí OUI ‚Üí Pattern <strong>CR√âATIONNEL</strong></p>
                
                <p><strong>2. Est-ce que je dois ASSEMBLER des classes bizarres pour qu'elles s'embo√Ætent ?</strong></p>
                <p>‚Üí OUI ‚Üí Pattern <strong>STRUCTUREL</strong></p>
                
                <p><strong>3. Est-ce que c'est un probl√®me de COMMUNICATION entre objets ?</strong></p>
                <p>‚Üí OUI ‚Üí Pattern <strong>COMPORTEMENTAL</strong></p>
            </div>

            <hr>

            <h2>üè≠ Patterns CR√âATIONNELS (Instancier les objets)</h2>
            
            <h3>Factory Method</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Classe abstraite avec m√©thode abstraite de cr√©ation. Les ConcreteCreator impl√©mentent en faisant "return new ConcreteProduct". C'est un cas particulier de Template Method o√π la m√©thode abstraite fait un new.</p>
            
            <h3>Abstract Factory</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Interface avec plusieurs m√©thodes de cr√©ation (createProductA, createProductB). Chaque ConcreteFactory cr√©e une famille d'objets li√©s.</p>
            
            <h3>Singleton</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Constructeur private, m√©thode getInstance(), attribut static instance. Une seule instance pour toute l'application.</p>
            
            <h3>Builder</h3>
            <p><strong>Comment le reconna√Ætre :</strong> M√©thodes chainables (retournent this), construction progressive, m√©thode build() finale. Utile pour objets avec beaucoup de param√®tres optionnels.</p>
            
            <h3>Prototype</h3>
            <p><strong>Comment le reconna√Ætre :</strong> M√©thode clone() ou copy(). Cr√©e de nouveaux objets en copiant un prototype existant.</p>

            <hr>

            <h2>üîå Patterns STRUCTURELS (Composition des classes et objets)</h2>
            
            <h3>Decorator</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Une classe impl√©mente une interface ET a un attribut de cette m√™me interface. Construction en couches "new Decorator1(new Decorator2(component))" qui finit par le component de base (PAS null). Chaque d√©corateur ajoute une fonctionnalit√©.</p>
            
            <h3>Adapter</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Une classe impl√©mente une interface cible et contient un attribut de la classe √† adapter. Convertit l'interface d'une classe en une autre interface attendue.</p>
            
            <h3>Composite</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Une classe impl√©mente une interface ET a un attribut qui est une collection sur cette interface (List&lt;Interface&gt;). Permet de traiter uniform√©ment les objets individuels et les compositions.</p>
            
            <h3>Facade</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Le projet contient plusieurs classes mais le main ne fait appel qu'√† une seule classe (la Facade). Simplifie l'interface d'un syst√®me complexe.</p>
            
            <h3>Flyweight</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Pool d'objets partag√©s, Factory pour r√©cup√©rer les instances. Optimise la m√©moire en partageant des objets similaires.</p>

            <hr>

            <h2>üéØ Patterns COMPORTEMENTAUX (Communication entre objets)</h2>
            
            <h3>Strategy</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Attribut de type interface inject√© dans le constructeur ou via setter. D√©l√©gation via "strategie.method()". Possibilit√© de changer de strat√©gie √† l'ex√©cution. Strategy a UNE SEULE m√©thode (sinon c'est Visitor).</p>
            
            <h3>Observer</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Liste d'observers (List&lt;Observer&gt;), m√©thodes attach(), detach(), notify(). Boucle for qui appelle update() sur chaque observer. Notification automatique des changements.</p>
            
            <h3>State</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Attribut √©tat, les m√©thodes d√©l√®guent via "etat.method()". Changement d'√©tat avec "etat = etat.method()". Attention √† ne pas confondre avec Decorator : State change le comportement, Decorator ajoute des fonctionnalit√©s.</p>
            
            <h3>Command</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Interface Command avec m√©thode execute(). Liste de commandes. Ex√©cution diff√©r√©e. Encapsule une action dans un objet. Utile pour undo/redo.</p>
            
            <h3>Chain of Responsibility</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Attribut successeur du m√™me type que la classe. Construction "new Handler1(new Handler2(null))" qui finit par null (PAS un component comme Decorator). La classe s'auto-appelle via "successeur.method()". Constructeur appelle "super(successeur)".</p>
            
            <h3>Visitor</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Ressemble √† Strategy MAIS avec PLUSIEURS m√©thodes (autant que de types de n≈ìuds diff√©rents). Par exemple : visiterValeur(), visiterGroupe(). Strategy a UNE m√©thode, Visitor en a PLUSIEURS.</p>
            
            <h3>Template Method</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Classe abstraite avec une m√©thode concr√®te qui appelle des m√©thodes abstraites. La m√©thode concr√®te d√©finit le squelette de l'algorithme, les sous-classes impl√©mentent les √©tapes variables.</p>
            
            <h3>Iterator</h3>
            <p><strong>Comment le reconna√Ætre :</strong> Interface avec hasNext() et next(). Permet de parcourir une collection sans exposer sa structure interne.</p>

            <hr>

            <h2>‚ö†Ô∏è Pi√®ges √† √âviter</h2>
            
            <div style="background-color: #fff3cd; border: 1px solid #856404; padding: 15px; margin: 20px 0;">
                <h3>Decorator vs Chain of Responsibility</h3>
                <p><strong>Decorator :</strong> Finit par le component de base</p>
                <p><strong>Chain :</strong> Finit par null</p>
                
                <h3>Strategy vs Visitor</h3>
                <p><strong>Strategy :</strong> UNE SEULE m√©thode</p>
                <p><strong>Visitor :</strong> PLUSIEURS m√©thodes (une par type de n≈ìud)</p>
                
                <h3>State vs Decorator</h3>
                <p><strong>State :</strong> Change le comportement selon l'√©tat</p>
                <p><strong>Decorator :</strong> Ajoute des fonctionnalit√©s</p>
                
                <h3>Template Method vs Factory Method</h3>
                <p><strong>Factory Method :</strong> Cas particulier de Template Method o√π la m√©thode abstraite fait un new</p>
            </div>

        </main>

        <footer>
            <p>¬© 2024 Design Patterns Course</p>
        </footer>
    </div>
</body>
</html>
